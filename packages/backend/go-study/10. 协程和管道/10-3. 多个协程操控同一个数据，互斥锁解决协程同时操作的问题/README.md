### 简介

可以从main.go中， 执行结果来看，跟想象中的0 是不一样的？？
问题出在哪里呢？？

### 问题分析
问题出在，有时候会出现，两个并行的协程，同时在读取和写入 total 字段的值，导致其混乱了，而不是预想的，每次只有执行一个携程。
可以看出，同一时间，出现了两个协程同时在运行


那么如何解决呢？？ 怎么样才能保证，两个协程，不会同时读取和写入total字段呢？？同时只有一个协程在读取和写入total字段呢？？


#### 互斥锁

互斥锁，可以保证，同一时间，只有一个协程在运行，其他协程，只能等待，直到锁被释放，才能继续运行。
```go
var mutex sync.Mutex

mutex.Lock() // 加锁
mutex.Unlock() // 解锁
```

互斥锁，Lock加锁之后。不可以继续加锁，除非解锁，解锁之后，才可以继续加锁。
适用于 读写不明确的场景，读写次数没有明显的区别
互斥锁的效率比较低，互斥锁就是无轮是读还是写，都会被加锁，除非解锁，解锁之后才能使用
但是有时候，读不受影响，只想要对写加上锁，来提高效率

但是性能和效率是比较低的，有没有更好地操作方式呢？？
