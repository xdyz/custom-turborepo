### 简介

管道channel

#### 管道的特质介绍
- 本质上是一种数据结构，是一种队列结构, 先进先出原则
- 自身处于线程安全，多协程访问时，不需要加锁，不会发生资源争抢问题
- 管道本身也是有类型的，一个string类型的管道，只能存储string类型的数据
- 默认情况下的管道，可读可写的，但是可以定义一个只读的管道，或者一个只写的管道

#### 管道的定义

var 变量名 chan 数据类型
- chan 为 管道的关键字
- chan 管道为引用类型
- chan 初始化时 必须使用make函数

```go
var c  chan int // 定义一个 存储int数据类型的管道c

c = make(chan int) // 初始化一个存储int数据类型的管道c
```


管道接受两个参数
- 第1个参数为管道要存储的数据类型
- 第2个参数为管道的容量，即管道中可以存储的最大数据量  默认值为0

#### 管道的使用

##### 管道数据的写入
 c <- 100   向管道中写入数据

##### 管道数据的读取
 v := <- c  从管道中读取数据

##### 管道的关闭
close(c)  关闭管道


##### 遍历管道
只提供 for range 语法，不能使用 普通for循环
```go
for v := range c {
  fmt.Println(v)
}
```
- 如果遍历管道时，管道没有关闭，此时是不能遍历管道的，会报错
- 如果遍历管道时，管道已经关闭，那么可以正常遍历管道，遍历完，就会退出遍历

##### 声明一个只写的管道
```go
var c chan<- int = make(chan<- int)
```

##### 声明一个只读的管道
```go
var c <-chan int = make(<-chan int)
```

##### 总结

```go
c <- 100 // 向管道中写入数据

v := <- c // 从管道中读取数据

close(c) // 关闭管道 但是，只是关闭管道的进门口，出门口依然可以继续从管道中读取没有取出的数据


// 循环输出管道的值
for v := range c {
  fmt.Println(v)
}

```

#### 管道的阻塞

- 管道只往里面写， 如果管道满了，就会阻塞（deadlock 死锁），直到有数据被取出，管道才会被释放
- 如果写得快，读得慢，不会引起阻塞问题 

#### 注意
- 不能存放大于容量个数的数据，不然会报错
- 同样，如果管道中，已经没有数据了，此时如果去取数据，会报错